# 计算机网络
### 1.TCP和UDP的区别
- TCP:	TCP是可靠，稳定的，有连接的。在传输数据之前会通过三次握手建立连接，连接建立以后还会有一系列的确认，窗口，重传，拥塞控制机制，需要断开连接时会进行四次挥手。虽然可靠，但是确是建立在一系列的保证机制下，消耗比UDP更多的时间和资源。常用于要求可靠的应用，如HTTP,HTTPS,FTP,POP,IMAP等协议。__
- UDP:	UDP是不可靠的，无连接的。UDP只负责将数据发出去，但是它并不负责数据是否被接收到了，所以说UDP是不可靠的。但也正因为它没有一系列的可靠机制，UDP的速度比TCP快很多。常用于可靠性要求不高的应用场景，如视频聊天，语言聊天等。

### 2. TCP是如何实现可靠传输的

- 编号：数据发送方要给发送的数据包编号，接收方接收到数据包后发送一个ACK信号，标明下一个数据包的初始字节编号
- 超时重发：发送方发送数据后在指定时间内没收到ACK信号，会重发数据，但间隔时间会指数级增长，达到一定时长才会断开连接
- 三次握手建立连接，四次挥手断开连接
- 发送方和接受方协商好发送的数据包的单位，称为 最大消息长度
- 滑动窗口： 滑动窗口前端为已发送但未收到ACK的数据，后端为未发送的数据。数据发送方一次发送多个数据包，滑动窗口每收到一个ACK信号，窗口就向后滑动，提高传输效率。
- 流量控制: TCP首部有一个字段设置滑动窗口大小，、通过设置它来控制传输流量
- 拥塞控制：为了避免双方传输大量数据，发送端刚开始发送数据时拥塞窗口从一个最大消息长度开始，每收到一个ACK信号后，拥塞窗口就扩大为原来的两倍。实际窗口大小取滑动窗口和拥塞窗口的最小值，同时设置一个慢启动阈值，当窗口大小大于阈值后，改为线性增长，知道遇到网络拥塞时，慢启动阈值设为此时窗口数的一半，再将拥塞窗口值设为1开始传输。重复如上操作。
- 快恢复
- 快重传

### 3.三次握手和四次挥手

- 三次握手：
- 第一次握手：发送端发送SYN信号给接收端，接收端收到SYN信号。
发送端什么都确认不了，接收端确认自己接收正常，发送端发送正常
- 第二次握手：接收端发送SYN/ACK信号，发送端接收SYN/ACK信号
发送端确认自己发送正常，接收正常，接收端发送，接收正常。接收端确认自己接收正常，发送端接收正常。
- 第三次握手：发送端发送ACK信号，接收端接收ACK信号，握手完毕，建立连接
发送端确认自己发送正常，接收正常，接收端发送，接收正常。接收端确认自己接收正常，发送正常，发送端接收正常，发送正常

SYN验证发送端到接收端的通道正常，ACK验证接收端到发送端的通道

- 四次挥手
- 要关闭连接的一方发送FIN信号给另一方，另一方发送ACK信号给要关闭连接的一方之后，要关闭连接的一方向另一方的通道就关闭了，无法主动传输数据给另一方了，但这时另一方到要关闭连接的一方的通道还没有关闭，已经关闭连接的一方还要被动接收数据。只有等另一方也主动关闭连接，发送FIN信号，已经关闭连接一方发送ACK信号，TCP连接才算真正断开了。

  

### 4.ARQ协议
### 停止等待ARQ协议
每发送一个分组，就要停止发送，等待对方的确认接收信号，并设置一个等待超时时间，如果超时，就重新发送这个分组，接收方如果收到重复的分组，直接丢弃该分组并发送确认信号，发送方收到重复确认信号，直接丢弃。
### 连续ARQ协议
不再一个一个分组发，而是维持一个发送窗口，一次发送好几个分组，接收方每采用累计确认的机制，向发送方发送最后一个接收到的分组的确认信号，如果窗口中间开始有分组没发送成功，那么下次发送方要重这个分组开始发送。

### 5.滑动窗口和流量控制
接收方会维护一个滑动窗口，窗口大小可以在TCP首部中设置，设计目的是为了控制和告知发送方发送速率，如果发送方发送数据太多，就会来不及接收导致丢包，这也叫流量控制。

### 6.拥塞控制
发送方的发送速率不止取决于接收方设置的滑动窗口大小，同时也受到网络拥塞的影响，发送方会根据网络情况维护一个拥塞窗口，发送方的发送窗口大小是拥塞窗口和滑动窗口的最小值。
拥塞控制采用四种算法：慢开始，拥塞避免，快重传和快恢复。

- 慢开始： 设置一个慢启动阈值，拥塞窗口初始值为1，每经过一个传播轮次，拥塞窗口值加倍
- 拥塞避免： 当拥塞窗口数到达慢启动阈值时，不再指数增长，而是线性增长，当遇到网络拥塞时，慢启动阈值设为此时窗口数的一半，拥塞窗口数再设为1，开始新的一轮慢开始和拥塞避免。
- 快重传和快恢复： 接收方收到不按顺序的分组，就会向发送方重复发送不按顺序分组的起始确认序号，发送方收到三次以上确认信号，就会知道接收方每收到这些分组，就会重这个序号开始重新发送分组。

### 7.浏览器输入网址显示网页的过程经历了什么
- 首先会根据网址去找服务器的ip地址，首先会去本机的host文件上找，接着去找浏览器上的DNS缓存，然后去找路由器上的DNS缓存，再找不到就去询问DNS服务器，服务器的结构和树很像，DNS ip查询时一层一层的，如果这一台服务器没有该域名的ip地址，那么它会知道下一层服务器谁有该域名的ip地址或知道哪台服务器知道该域名的ip地址，一层层查询，然后返回ip地址。
- 接着浏览器会尝试与该服务器建立TCP连接，连接成功后发起HTTP请求，连同Cookie等用户数据一起发送给服务器
- 服务器接收到HTTP请求和用户数据，会根据请求路径，参数，用户数据进行处理生成HTML响应
- 服务器发送HTML响应给浏览器
- 浏览器渲染HTML响应生成HTML页面
- 数据在中间传输时会用到TCP/IP协议，OSPF路由选择协议，ARP ip转换为mac地址 协议，HTTP协议

### 8.HTTP长连接（1.1以上)和短连接(1.0)
- HTTP1.0时，采用的是TCP的短连接，客户端每次访问一次服务器资源，就建立一个连接，访问完资源后又断开连接。
- HTTP1.1及以上就默认使用长连接了，只要在响应头加入 Connection：keep-alive，就表明使用长连接



# 操作系统
### 1.进程和线程的区别
- 进程是资源分配的基本单位（CPU、存储空间和I/O设备），由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。线程独立运行，独立调度，拥有资源（一般是CPU资源，程序计数器等），可以调度隶属于进程的资源
- 一个进程至少有一个线程，一个线程只属于一个进程
- 进程的创建，销毁，和切换的系统开销远大于线程的创建，切换和销毁
- 因为线程间的资源是共享的，线程可以直接读写进程数据进行通信，进程通信需要通IPC

### 协程

- 协程是用户模式下的轻量级线程，操作系统内核对协程一无所知
- 协程的调度完全有应用程序来控制，操作系统不管这部分的调度
- 一个线程可以包含一个或多个协程
- 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下纹和栈保存起来，在切换回来时恢复先前保运的寄存上下文和栈
- 协程能保留上一次调用时的状态，看到这里各种生成器（生成器是被阉割的协程）的概念浮现出来了。。
- Windows下的实现叫纤程

### 2.进程状态的切换
![1525529091749](https://img-blog.csdn.net/20160929210812975)
每当进程获得CPU时间，就会从就绪态转换为运行态，CPU时间结束就会变成就绪态，当运行态时缺少需要的资源，就会从运行态转换成阻塞态，当获得需要资源后才会从阻塞态转换成就绪态。

### 3.进程调度算法
1.先来先服务（FCFS），非抢占式
2.最短作业优先（SJF)，非抢占式
3.剩余最短作业优先（SRTN)，抢占式
4.时间片流转
- 按照FCFS的规则维护一个进程调度队列，当CPU时间片到来时，取出队首进程，执行一个CPU时间片后，计时器发出时钟中断，调度程序停止进程的执行，保存上下文后将进程放到队尾，然后执行下一个队首进程。
- 时间片的长度设置很有考究，太短，频繁进行进程上下文切换，真正执行进程的时间就会很短，效率不高，太长，实时性又得不到保证。
5.优先级调度
- 给每一个进程设置一个优先级，优先级高的有更高的几率被调度执行。为防止优先级低的很难得到执行，可以随着进程等待时间的增加提高优先级。
6.多级反馈队列
设置多级调度队列，最上层队列的时间片最小，每下一层时间片就翻倍，最上层队列优先级最高，在该层时间片长度下进程还没执行完的话，就会进入下一层队列，只有上一层调度队列为空，本层队列才会开始调度，这样可以减少长时间进程的切换上下文次数。

### 4.进程同步
### 临界区
访问临界资源的代码叫做临界区
进程访问临界区的时候要进行检查，为了互斥访问
### 同步与互质
同步：进程间存在合作关系，有一定的先后执行顺序
互斥：同一时间只有一个进程可以进入临界区
### 信号量
信号量是一个整型数，有down和up，也就是P和V操作
down：当信号量大于0时，down操作使信号量减一，信号量等于0，阻塞等待
up：up操作使信号量加一，唤醒阻塞等待的进程完成down操作
down和up操作具有原子性，原理是在执行这些操作时不可中断
若信号量只有0和1，那么就叫互斥量，0时临界区加锁，1时临界区解锁

### 经典同步问题

### 进程通信
- 管道：只支持父子进程间的通信，是半双工通信
- FIFO： 解除管道只支持父子进程通信的限制，常用于客户进程和服务进程的通信
- 消息队列
- 信号量： 控制多个进程对临界资源的访问
- 共享存储：开辟一个空间作为多个进程的共享存储区，不再需要复制数据到进程，是最快的IPC
- 套接字：特点是可用于不同机器间的进程通信

### 死锁
### 死锁的必要条件
- 互斥：每个资源要么已经分配给一个进程不可用，要么就是可用的
- 占有和等待： 已经拥有资源的进程还可以请求其他资源
- 不可抢占：进程不可抢占其他进程的资源，直到其他进程显式的释放资源
- 环路等待：由两个或两个以上的进程形成的环形等待下一个进程资源的环

### 发生死锁时的处理方式
- 鸵鸟策略：当发生死锁概率很低或影响很小时，可以直接忽略死锁，因为解决死锁代价很高
- 死锁检测
（1）一个进程只能有一种类型资源的可以将进程和资源关系用图来表示，然后查找该图有没有环，有就是存在死锁。
（2）一个进程可以拥有几种类型的资源可以用资源矩阵来描述进程和资源的关系，通过算法检测死锁
- 死锁恢复
（1）允许抢占
（2）销毁进程
（3）回滚恢复
- 死锁预防
破坏死锁的必要条件即可
1.破坏互斥条件
2.破坏占有并等待：进程只能一次请求所有需要的资源
3.破坏不可抢占：运行进程抢占其他进程的资源
4.破坏环路等待：给资源编号，只能按序请求资源
- 死锁避免：简单来说就是检测到进程行为将会导致死锁，那么将不执行进程行为

### 内存管理
### 虚拟内存
- 首先大概讲讲操作系统的内存管理，每个程序都有一定大小的地址空间，这个空间可以不连续，也就是可以分成许多块，每块称为一页。这就使小内存的操作系统可以运行高内存的程序，只需要将程序当前执行所需要的页放到内存，把其他的页放到虚拟内存，也就是磁盘，当引用到不在内存的页时，根据淘汰算法淘汰页，将缺失的部分从虚拟内存装入物理内存，完成程序的执行。

### 页面置换算法
- 最佳：就是置换未来最久才使用的页，但只是理论算法
- LRU（最近最久未使用）：可以用LinkedHashMap数据结构来实现，其底层就是LRU，将最新访问的结点放到链表表头，这样就可以找到最近最久未使用的页，也就是链表尾，但开销很大

### 分段和分页
纯分页会将一个程序和程序的数据划分成多页，为了将程序和数据划分成逻辑上独立的地址空间，有利于共享和保护，引入分段，分段的大小是可以调整的。但我们还想要能够使用虚拟内存的话，可以采用段页式划分内存，一个段里有多个页。

分段和分页的区别
- 分页对程序员是透明的，分段是显式的
- 页大小不可变，段大小可变
- 分页是为了实现虚拟内存，获得更大的地址空间。分段是为了将程序和数据划分成逻辑上独立的地址空间有助于共享和保护。

### 磁盘任务调度算法
其目的是为了减少寻道时间，也就是让磁头移动距离最短
- FCFS（先来先服务）：根据磁盘请求顺序移动磁头，最垃圾的算法，平均寻道时间一般最长
- 最短寻道时间优先算法（SSTF)：优先调度离当前磁头最近的请求。容易出现饥饿现象，尤其是两端的请求
- 电梯算法（SCAN): 从当前磁头向一个方向出发，处理沿路请求，直到该方向上没有请求再调头，循环处理请求，解决了SSTF的饥饿问题。

### select，poll，epoll之间的区别
	select：无差别轮询所有流，找出能读出数据或写入数据的流，o(n)复杂度,单个进程能监听端口的大小有限，32位是1024，64位是2048
	poll:poll本质上和select没有区别，它没有最大链接数的限制，原因是它是基于链表来存储的，也是通过轮询，o(n)复杂度
	epoll：epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，内核就会采用类似callback的回调机制来激活该fd（文件描述符），epoll_wait便可以收到通知，（复杂度降低到了O(1)）。
	但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### BIO，NIO，AIO

A顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)

B顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）

C顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是C顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）

#### 同步与异步

​    同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。

​	同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。

​	异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为

#### 阻塞与非阻塞

阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。

阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。

非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。

阻塞与非阻塞关注的是线程是否在原地等待。

#### BIO

BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。

#### NIO

NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。

NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。

#### AIO

AIO是真正意义上的异步非阻塞IO模型。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。

AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。

# 数据库系统原理

### 事务
事务的特性
- 原子性：一个事务要看出原子操作，要么一起成功，要么失败回滚
- 一致性：数据库在事务执行前后都保持一致性，只有保持一致性，事物的执行结果才是正确的。
- 隔离性：事务的中间操作过程对其他事务来说是不可见的
- 持久性：一旦事务提交，要将所做修改保存到数据库上。即使系统崩溃，事务执行结果也不能丢失

这几个特性的关系
- 只有保证事务的一致性，事务执行结果才是正确的
- 在单线程串行执行事务时，只有保证事务的原子性才能保证一致性
- 在并行条件下执行线程，只有保证事务的原子性和隔离性才能保证一致性
- 持久性就不用说了吧，不持久还用数据库干嘛

### 并发情况下的一些一致性问题
- 丢失修改：事务T1和T2同时修改一个数据，T1先执行完毕，T2后执行完毕，就会丢失T1对数据的修改
- 脏读：在一个事务中，读一个数据时读到了另一个事务的数据，然后另一个事务还回滚了
- 不可重复读： 在一个事务中，重复读取一个数据的前后结果不一致
- 幻读：一个事务中前一次读取到的数据行数和下一次读取到的数据行数不一致

可以通过程序员加锁来控制，保证一致性，也可以调整数据库隔离级别

### 封锁粒度
mysql中有两种封锁粒度：行级锁和表级锁
- MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

### 封锁类型

- 读写锁
共享锁S，排他锁X
一个事务对数据对象A加了X锁，就可以读取和更新数据对象A。其他事务就只能干等着。
一个事务对数据对象A加了S锁，就可以读取数据对象A。其他事务不能给对象A加X锁，但可以加S锁
- 意向锁
加入意向锁IX,IS，IX和IS是表级锁，支持多粒度封锁，也可以减少检测锁的开销。
如果没有IS,IX锁，那么事务要给表A加上X锁，就需要遍历表A所有行有没有加S锁或X锁，开销非常大。有了IS,IX表级锁，截然不同。只需要检测表A有没有加X/S/IX/IS锁，就可以检测出来。

锁之间的兼容情况
-	X	IX	S	IS
	X	×	×	×	×
	IX   ×	√	×	√
	S	×	×	√	√
	IS   ×	√	√	√

### 封锁协议
- 一级封锁：解决丢失修改一致性问题，在修改数据前要加X锁，那么其他事务就不能同时修改数据
- 二级封锁：解决脏读问题，其他事务要读取数据需要加S锁，读取完成立即释放
- 三级封锁：解决不可重复读问题，读取数据要加S锁，事务完成后才释放S锁

### 隔离级别
- 未提交读： 事务的中间数据修改对其他事务来说是可见的
- 提交读：事务只能读取已提交事务所做的修改
- 可重复读：一个事务中重复读一个数据不会出现不一致的现象
- 可串行化：串行执行事务，一致性绝对保证，但效率低下
	隔离级别	脏读	不可重复读	幻影读
	未提交读	   √		√		  √
	提交读		    ×		   √		√
	可重复读	   ×	         ×		     √
	可串行化	   ×		×		   ×

### 多版本并发控制
多版本并发控制也叫MVCC，只能用于实现提交读和可重复读，未提交读不需要，可串行化MVCC无法实现
- 版本号
系统版本号：每开启一个事务，系统版本号就会自动递增
事务版本号：事务开始时的系统版本号
- 隐藏列
每行数据都有两个隐藏列 
创建版本号，创建，修改数据行时把系统版本号赋给创建版本号
删除版本号，删除数据行时把系统版本号赋给它，或修改数据行时把原来的创建版本号给它
在undo日志里，会保留数据行的快照，包括创建版本号和删除版本号
- 以下讲一讲个人对可重复读隔离级别实现的理解
- SELECT：多个事务访问同一数据行，所访问到的数据行的创建版本号一定要比事务版本号小，删除版本号一定要是未定义或比事务版本号大，原因很明显呀，数据要是事务版本号之前的版本并且还未被删除。
- INSERT:更新数据行的创建版本号为事务版本号，删除版本号未定义
- DELETE：更新数据行的删除版本号为事务版本号，
- UPDATE：将当前数据的前一个快照的删除版本号更新为当前事务版本号，将当前数据行的创建版本号更新为当前事务版本号

### NEXT-KEY LOCKS
NEXT-KEY LOCKS是mysql Innodb存储引擎的一种锁实现
其存在意义是为了结合MVCC解决幻读的问题
其核心思想就是锁定索引的间隙，但不包含索引本身，简单来说就是事务有统计数量的语句出现时，就锁定语句where范围，不让其他事务插入这个范围的数据，这样就不会出现幻读了。

## MYSQL
### 索引
- 讲一下B-树和B+吧
为了减少查询次数，用B树和B+树来存储索引，为什么不用二叉搜索树呢，因为二叉搜索树树的高度太高，而数据太多的话就无法全部放进内存，这样每一次查询下一层就有一次磁盘IO，为了减少磁盘IO，就需要矮胖的B树和B+树。
B树的中间节点有k-1个元素和k个孩子指针，结点大小是有序的，并且中间结点都有卫星数据，卫星数据就是索引元素所指向的数据，输入数据库的某一行数据。
B+树和B树大体相同，但有以下几点区别：
- B+树的中间结点没有卫星数据，只有叶子结点才有卫星数据，并且有大量重复元素。
- B+树结点的元素个数和孩子指针树数量一致，每个元素的孩子指针都指向一个有序的结点，且元素是这个结点的最大值或最小值
- B+树在叶子结点中的结点有指向下一个结点的指针，其实也就是一个链表，方便范围查询。
- B+树每次IO查询只会查找一个簇，减少IO浪费

做点补充
B+树查询效率稳定，每次都要查询到叶子结点，然后数据库查找数据时一般会做预读处理，直接查找一页数据，减少磁盘IO次数。

### MYSQL索引
每一种存储引擎都有自己的索引类型和实现，接下来介绍一些索引实现
- B+树索引
是大多数MYSQL存储引擎的默认索引类型
可以指定多个列作为索引列，多个索引列共同组成键。
多个列作为索引时要注意最左前缀匹配问题，避免查询时没有命中索引。
InnoDB的B+树索引分为主索引和辅助索引。
主索引的叶子结点的data域包含完整数据记录，这种索引方式被称为聚簇索引，一个表只能有一个聚簇索引。
辅助索引的叶子结点的data域记录主键值，因此在使用辅助索引查找时，先找到主键值，再去聚簇索引查找数据。

- 哈希索引
哈希索引虽然可以O(1)查找,但失去有序性,无法排序,无法分组,无法范围查询
但在某个索引值被频繁查找时,会在B+树索引之上再创建一个哈希索引,这样就让B+树索引查找速度更快

- 全文索引
MYISAM 存储引擎支持全文索引,用于查找文本中的关键字,而不是直接比较是否相等
使用方法是使用关键字MATCH AGAINST,而不是普通的WHERE
全文索引使用倒排索引实现,它记录着关键词到其所在文档的映射
InnoDB存储引擎再MYSQL5.6.4版本开始支持全文索引

### 索引的一些细节
- 使用索引,也就是sql语句 where后面 索引列不要乱搞,做一些运算什么的,会导致无法命中索引
- where查询有多列时,可以建立多列索引
- 建立多列索引要把区分度最高的一列放在最前面,查询效率会变高
- 最好索引包含所有需要查询的字段的值,索引通常远小于数据行的大小,只读取所有能大大减少数据访问量.   一些存储引擎(如MYISAM)在内存只缓存索引,数据依赖操作系统来缓存.只访问索引可以大大减少时间.  对于Innodb来说,若辅助查询能够覆盖查询,那么就不需要访问聚簇索引,也就没有二次查询.

### 索引的优点
- 大大减少了服务器需要查询和扫描的数据行数
- 帮助服务器避免排序,分组和创建临时表,因为B+树索引时有序的,OrderBy和 GROUP BY时直接顺序查询就好,不需要分组,不需要排序,也就不需要临时表
- 将随机I/O变成顺序I/O,减少I/O时间

### 索引的使用限制
- 对于非常小的表,还不如简单的全表扫描
- 中型到大型表.索引就有用武之地
- 对于特大型的表,建立和维护索引的开销太大,就要使用其他手段,如分区技术

### 查询性能优化
- 使用Explain进行分析
Explain可以用来分析SELECT语句,作用是在SELECT语句查询数据后增加一些列,比较重要的有rows,select_type和key
- 减少请求的的数据量
只返回必要的列,尽量避免SELECT *
只返回必要的行,尽量使用LIMIT
缓存经常查询又不经常更新的数据，对性能提升非常明显
- 减少服务端扫描行数
使用索引
- 切分大查询：如果一个大查询一次性执行的话，会占用很多资源，锁住很多数据，阻塞一些很小但重要的查询，所以要切分大查询
- 分解大连接查询
将大连接查询分解为多个单表查询有很多好处
缓存更高效，单表查询可以提高缓存命中率
减少锁竞争
查询效率也会提高

### 存储引擎
- InnoDB
InnoDB是MySQL的默认存储引擎，只有在需要它不支持的特性时，才使用其他引擎
实现了四种隔离级别，分别是读未提交，读提交，可重复读，串行化。默认隔离级别是可重复读，通过MVCC解决脏读，可重复读，再结合NEXT-KEY LOCKS解决幻读
主索引是聚簇索引，在索引中存放数据，避免直接读取磁盘，大大提升性能
内部做了很多优化，比如磁盘的预读取，根据情况自动创建哈希索引提高查询效率，创建插入缓冲区提高插入效率
支持在线热备份，其他存储引擎不支持在线热备份。
- MyISAM
设计简单，数据存储紧密，对于只读数据，或者表比较小，可以容忍修复操作，就可以使用它
也有很多特性，如压缩表和空间数据索引。
不支持事务
不支持行级锁。只支持表级锁，在读取数据时会对相关表加共享S锁，在写入数据时会对相关表加排他锁，值得一提的是表在加了共享锁后还可以插入数据，这叫并发插入。
可以手动或自动执行检测和修复操作，但和事务恢复和崩溃恢复不同，可能会有数据丢失，并且修复速度非常慢
如果指定了DELAY_KEY_WRITE,那么修改索引数据后不会立即写入磁盘，会写到内存的键缓冲区只有等到清理键缓冲区或关闭表时才会写入磁盘，对效率提升非常明显，但是一旦主机或数据库崩溃，要执行非常慢的修复操作

### InnoDB和MyISAM的区别
- InnoDB支持事务，MyISAM不支持事务
- MyISAM只支持表级锁，InnoDB还支持行级锁
- InnoDB支持外键，MyISAM不支持
- InnoDB支持在线热备份，MyISAM不支持
- MyISAM崩溃恢复数据损坏概率比InnoDB崩溃恢复高得多，速度也慢很多
- MyISAM支持压缩表和空间数据索引，InnoDB不支持
- CHAR定长和VARCHAR变长，所以最好使用VARCHAR，但是使用VARCHAR可能会导致数据行变长，超出一个页所能容纳的大小。这时MyISAM会将行拆分成不同的片段存储，InnoDB会分裂页把行放进去。
- InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count() from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。
- - MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count() from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选




### 数据类型
- TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别占用8，16，24，32，64位空间
- FLOAT,DOUBLE,DECIMAL都是浮点数，但是CPU原生不支持DECIMAL运输，所以效率会低
- CHAR定长和VARCHAR变长，所以最好使用VARCHAR，但是使用VARCHAR可能会导致数据行变长，超出一个页所能容纳的大小。这时MyISAM会将行拆分成不同的片段存储，InnoDB会分裂页把行放进去。
- DATETIME和TIMESTAMP，8个字节，4个字节，TIMESTAMP记录1970年到2038年，尽量使用TIMESTAMP节省空间

### 切分
- 水平切分
随着表的数据不断增多，超过500W条时查询效率就会很低，这时候就需要水平切分表，将数据分布到集群的不同节点，从而减缓单个数据库的压力
- 垂直切分
垂直切分是把表按照列的使用频率不同进行切分，这样查询表的时候就不用经常查询遍历不经常使用的数据，提高查询效率

### 切分策略（Sharding）
- 哈希取模：hash（key）%N
- 范围：可以是ID范围，也可以是时间范围
- 映射表：可以使用单独的库来存储映射关系

### sharding存在的问题
- 事务问题： 使用分布式事务来解决，如XA接口
- 连接问题：将多表查询分解成多个单表查询，然后在用户程序进行连接
- ID的问题：
采用雪花算法算出唯一的ID值
为每个分片指定一个ID范围
使用全局唯一ID（GUID)

### 常用的Mysql复制架构有哪些？
（1）一主多从 在主库读取请求压力非常大的场景下, 可以通过配置一主多从复制架构实现读写分离, 把大量对实时性要求不是特别高的读请求通过负载均衡分布到多个从库上, 降低主库的读取压力，在主库出现异常宕机的情况下, 可以把一个从库切换为主库继续提供服务 。

（2）多级复制 一主多从的架构能够解决大部分读请求压力特别大的场景的需求, 考虑到 MysQL的复制是主库“推送” Binlog日志到从库,主库的 I/0压力和网络压力会随着从库的增加而增长(每个从库都会在主库上有一个独立的 Binlog Dump线程来发送事件), 而多级复制架构解决了一主多从场景下,主库额外的 I/0和网络压力。

（3）双主复制/Dual Master 其实就是主库 Master和 Master2互为主从， client客户端的写请求都访问主库 Master,而读请求可以选择访问主库 Master或 Master2。


### 数据库主从复制

主要涉及三个线程：binlog线程，IO线程，SQL线程
- binlog线程：负责将主服务器的每一次数据更改写入binlog（二进制日志中）
- IO线程：读取主服务的二进制日志，写入从服务器的中继日志
- SQL线程：读取中继日志，将数据还原到从服务器上

### 主从数据库读写分离
职能：主服务器处理写操作以及实时性要求比较高的读操作，从服务器负责大部分读操作
使用主从服务器的好处
- 读写分离，缓解了锁争用
- 从服务器可以使用MyISAM存储引擎，提升查询性能和系统开销
- 增加冗余，提高可用性
读写分离常用代理方式来实现，使用代理服务器接收用户读写请求，根据请求不同发给主从服务器

### 什么 是存储过程
存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
优点：

1、重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。

2、减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。

3、安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。
缺点：移植性差

```sql
delimiter //
create procedure p3()
Begin
show tables;
End //
delimiter;
```



### 说说存储过程与函数的区别
（1）存储过程用户在数据库中完成特定操作或者任务（如插入，删除等），函数用于返回特定的数据。

（2）存储过程声明用procedure，函数用function。

（3）存储过程不需要返回类型，函数必须要返回类型。

（4）存储过程可作为独立的pl-sql执行，函数不能作为独立的plsql执行，必须作为表达式的一部分。

（5）存储过程只能通过out和in/out来返回值，函数除了可以使用out，in/out以外，还可以使用return返回值。

（6）sql语句（DML或SELECT)中不可用调用存储过程，而函数可以。
### 什么是 内连接、外连接、交叉连接、笛卡尔积等?
- 内连接: 只连接匹配的行 

- 左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行

- 右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 

例如1：

```sql
SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username
```


例如2：

```sql
SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username
```

- 全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 例如：

```sql
SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type
```




### 事务和锁的区别
1、事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。

2、事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的。

3、开启事务就自动加锁。

### 什么是内存泄漏
指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 

### 简单说一说drop、delete与truncate的区别

SQL中的drop、delete、truncate都表示删除，但是三者有一些差别

delete和truncate只删除表的数据不删除表的结构

速度,一般来说: drop> truncate >delete 

delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;

如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 

运用场景：

不再需要一张表的时候，用drop

想删除部分数据行时候，用delete，并且带上where子句

保留表而删除所有数据的时候用truncate

### redo log

- innoDB会先把更新的记录写在redo log里面，并更新内存，innoDB会在适当时候，将更新写到磁盘里面
- redo log是固定大小的，是一个循环文件，有个checkpoint和writeposition，从头开始写，写到末尾又回到开头循环写

## Redis

### redis是多线程还是单线程

![1593352363(1)](D:\学习\我的笔记图片\1593352363(1).jpg)

文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

 Redis 确实是单线程模型，指的是执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程

一般来说 Redis 的瓶颈并不在 CPU，而在内存和网络。如果要使用 CPU 多核，可以搭建多个 Redis 实例来解决。

其实，Redis 4.0 开始就有多线程的概念了，比如 Redis 通过多线程方式在后台删除对象、以及通过 Redis 模块实现的阻塞命令等。

 Theaded IO 指的是在网络 IO 处理方面上了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。Redis基于Reactor模式开发了网络事件处理器

Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

目前对于单线程 Redis 来说，性能瓶颈主要在于网络的 IO 消耗

### **redis能够快速执行**

> (1) 绝大部分请求是纯粹的内存操作（非常快速），因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

> (2) 采用单线程,避免了不必要的上下文切换和竞争条件，**不需要各种锁的性能消耗**，**单线程多进程集群方案**

> (3) 非阻塞IO - IO多路复用
>
> 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。

# Spring

### IOC控制反转和DI依赖注入
- IOC：IOC是一种设计思想，不是一种设计模式，这种思想被应用在Spring中。IOC是这样的，以往我们需要显式地根据类的构造方法创建类，用了IOC的话，我们只要在配置文件或注解里写好依赖关系，接下来就可以直接拿来使用，并且使用IOC容器的对象的话默认情况下都是单例的，不用再去写类的单例模式，既省事又节约了内存。
- DI依赖注入：是实现控制反转的一种设计模式，就是将实例对象传入到一个对象中。

### Spring中用到的设计模式
- 工厂设计模式
Spring中的BeanFactory和ApplicationContext使用工厂设计模式创建Bean
BeanFactory是懒加载策略，Application则是一次性创建所有配置的Bean对象
- 单例设计模式
可以节省创建对象的时间，尤其是重量级对象，效果非常明显
只创建一次对象，没有频繁的new对象，GC次数就会减少
- 代理设计模式
Spring AOP和AspectJ AOP采用了代理设计模式，将业务代码共同调用的代码封装起来，减少系统的重复代码，降低耦合度，提高系统的可维护性和可拓展性。
Spring AOP要代理的对象实现了某个接口，就会使用JDK Proxy去代理对象，对于没有实现接口的对象，就使用CGLIB，生成一个被代理对象的子类来作为代理
除此之外，你还可以使用AspectJ来代理，Spring AOP已经集成了AspectJ，动态代理是运行时增强，AspectJ代理是编译时增强，效率更高。
- 模板方法模式
Spring对数据库操作对象使用了很多模板对象，如JDBCTemplate，HibernateTemplate，一般使用继承来实现模板类，但Spring使用CallBack
- 观察者模式
观察者模式时一种对象行为型模式，Spring应用模式于Spring事件驱动模型，实际应用有每次修改数据库数据时都要重新更新索引，这时就可以利用观察者模式来解决这个问题，修改数据时观察到修改数据的行为，然后更新索引。
- 适配器模式
适配器模式将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。其别名为包装器（Wrapper）
Spring AOP的接口AdvisorAdapter就使用了适配器模式
SpringMVC 的HandleAdapter也使用了适配器模式
- 装饰者模式
装饰者模式可以动态地给对象添加一些额外地属性或行为。相比于使用继承，装饰者模式更加灵活。JDK就有很多地方用到了装饰者模式，比如InputStream家族
Spring配置DataSource地时候用到了装饰者模式


### Spring事务传播行为
为了解决Service层代码事务的相互嵌套问题，即事务方法被另一个事务方法调用时，事务该如何传播，Spring提供如下七种传播行为
- REQUIRED:如果当前存在事务，就加入当前事务，否则，创建一个新的事务
- SUPPORTS：如果当前存在事务，就加入当前事务，否则，就以非事务运行
- MANDATORY：如果当前存在事务，就加入当前事务，否则，就抛出异常
- REQUIRE_NEWS:创建一个新的事务，如果当前存在事务，就将它挂起
- NOT_SUPPORTS:以非事务运行，如果当前存在事务，就将它挂起
- NEVER:以非事务运行，如果当前存在事务，就抛出异常
- NESTED：如果当前存在事务，就创建事务作为当前事务的嵌套事务来运行，否则，创建一个新的事务

### SpringBean的作用域
- singleton：单例模式，是最常用，Spring默认的作用域
- propotype：多例模式，每次请求都会创建一个新的bean
- request：每一次http请求都是新建一个bean，该bean只在http request内有效
- session： 每一次http请求都会创建一个新的bean，该bean仅在session内有效
- globalSession：仅在portlet应用内有意义

### SpringBean的生命周期
- bean创建前有init方法和销毁前有destroy，可以在配置文件配置和类使用注解配置
简单讲讲SpringBean单例和多例的生命周期
- Singleton: 可以设置成懒加载，但Spring默认一次加载全部Bean。
Spring读取xml文件，创建配置好的对象，先调用构造方法，再调用init-method属性指定的方法，在Bean要被销毁时调用destory-method指定的方法
-Propotype：Spring读取xml文件时，不会马上创建bean，而是每来一个请求再创建bean，调用构造方法，再调用init-method指定方法，然后Spring就会对这个bean不管不问了。



### @RestController和@Controller
可以这么说，@RestController = @Controller+@ResponseBody，一般是用于前后端分离开发，再Spring4.0以后出现的RestController，也就是说，再Spring4.0之前前后端分离开发要返回json或xml格式要用到@Controller+@ResponseBody

### 单例模式bean的线程安全问题
当多个线程操作同一个对象时，对这个对象的非静态成员变量进行写操作会存在线程安全问题。
解决方案：使用ThreadLocal成员变量，将需要修改的成员变量放到ThreadLocal中
			       尽量避免定义可变的成员变量

### 谈谈对SpringMVC的了解
- Model1时代：几乎全部用jsp和javabean开发，代码冗余，混乱，开发难度大
- Model2时代：JSP作为视图层，Servlet作为控制层，JavaBean作为模型层，初步体现了MVC思想，但代码分层还是不明显，封装性不强
- Struts应运而生，但Strusts2比较笨重
- 最终，SpringMVC诞生了，SpringMVC是当前最优秀的MVC框架，比Struts2更快更简单更方便。SpringMVC下我们一般将项目分成Controller层，Service层，Dao层，Entity层。

### SpringMVC的工作原理
![SpringMVC工作原理图](https://camo.githubusercontent.com/6889f839138de730fce5f6a0d64e33258a2cf9b5/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d31312f34393739303238382e6a7067)



- 客户端送请求，直接请求到DispatcherServlet
- DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler
- 解析到对应的Handler，也就是请求对应的Controller后，开始有HandlerAdapter适配器处理
- HandlerAdapter会根据Handler来调用真正的处理器开始处理请求，并处理相应的业务逻辑
- 处理器处理完业务后，返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的view
- ViewResolver会根据逻辑View查找实际的View
- DispatcherServlet把返回的Model传给View（视图渲染）
- 把View返回给请求者



### @Component和@Bean的区别

- @Component只能作用于类，@Bean只能作用于方法
- 我们给类加上@Component时，在@ComponentScan设置扫描的路径，那么Spring启动时就会自动扫描路径下所有的包含@Component的类并创建Bean，而@Bean一般加在有返回值的方法上，Spring会自动执行代码并创建Bean在IOC容器里
- @Bean比@Component更灵活，某些情况下只能由@Bean来注入对象



### 把一个类声明为Spring Bean的注解有哪些

- @Component
- @Controller
- @Service
- @Repository



### Spring管理事务的方式有哪些

- 编程式事务，在代码中硬编码
- 声明式事务，在配置文件中配置或用注解的方式



### Spring定义的隔离级别有哪些

- 采用数据库默认的隔离级别，MySQL为可重复读，Oracle为提交读
- 读未提交：运行事务读取其他事务尚未提交的数据，无法避免脏读，不可重复读，幻读
- 读提交：事务只能读取到其他事务提交后的数据，中间数据无法读取，无法避免不可重复读，幻读
- 可重复读：同一事务对同一字段的多次读取结果都是一致的，除非本事务自己修改字段，无法避免幻读
- 串行化：事务串行处理，没有问题，但是太慢



### @Transactional（rollbackfor = Exception.class)

默认情况下，加了@Transactional的类或方法出现运行时异常时才会回滚，添加rollbackfor属性可以让程序在遇到我们定义的异常类型时也发生回滚

### Spring是如果解决循环依赖的

	创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；
	1、构造器的循环依赖。（spring也无能为力）
	2、setter循环依赖：
	Spring是先将Bean对象实例化【依赖无参构造函数】--->再设置对象属性的
	Spring先用构造器实例化Bean对象----->将实例化结束的对象放到一个Map中，并且Spring提供获取这个未设置属性的实例化对象的引用方法。结合我们的实例来看，，当Spring实例化了A、B、C后，紧接着会去设置对象的属性，此时A依赖B，就会去Map中取出存在里面的单例B对象，以此类推，不会出来循环的问题喽。




### 非持久化一个字段的方式

用static修饰

用final修饰

用transient修饰

用@Transient修饰

### 拦截器和过滤器的区别

![img](https://upload-images.jianshu.io/upload_images/3145530-020d025ad5576bd2.png?imageMogr2/auto-orient/strip|imageView2/2/w/932)

# maven

### maven的morro搜索顺序

local_repo > settings_profile_repo > pom_profile_repo > pom_repositories > settings_mirror > central



# 项目经验

### 项目微服务架构

浏览器请求先经过Nginx，Nginx拦截用户请求，根据用户请求域名的不同比较配置映射文件，将请求发往不同的Zuul网关，Zuul根据请求的路径，比对从Eureka拉取的服务名，找到服务对应的ip和端口，然后再进行访问，返回的数据再一层层返回，最后浏览器渲染页面



### CORS解决跨域问题

只有ajax访问才会出现跨域问题，跨域跨域，就是域名不同

客户端发起访问ajax请求，请求头会有orgion，内容为协议，域名加端口

服务端会根据这个值允许是否跨域，允许跨域请求就会添加响应头

简单请求就是这样

PUT什么的复杂请求会不太一样，会有预检请求



### 消息队列

使用RabbitMQ消息队列实现服务间的通信

说一个具体使用场景，生产者商品服务出现增删改时，就会绑定消息到交换机上并争对不同的操作绑定不同的key，对这个消息感兴趣的搜素微服务就会绑定消费者队列到交换机上，并指明自己感兴趣的消息的key，这样，商品增删改完成后，不用关心搜索微服务有没有更新好索引，只需要将消息发送给交换机之后，就可以干自己该干的事情的。

并且，使用消息队列还可以解耦，如果不使用消息队列，必然要再商品微服务上远程调用更新搜索微服务的代码，就会出现代码冗余的现象。

### 数据库如何优化
优化从三个方面考虑：SQL语句优化、主从复制，读写分离，负载均衡、数据库分库分表。
1，SQL语句优化：
- 建立索引可以使查询速度得到提升，我们首先应该考虑在where及order by，group by涉及的列上建立索引。
- 任何地方都不要使用SELECT * FROM语句
- 不要在索引列做运算或者使用函数
- 查询尽可能使用limit来减少返回的行数
- 使用查询缓存，多余查询很频繁的数据可以放在redis中

2，主从复制，读写分离，负载均衡
- 通过配置两台（或多台）数据库的主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。实现数据库的读写分离，从而改善数据库的负载压力。一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作（简单的轮询算法来决定使用哪个slave）

3，数据库分表、分区、分库
- 分表：
一，垂直拆分，把访问频率高的和访问频率低的分别放在不同的表中，这些表的主键相同
二，水平拆分，把一张表水平拆分，放到集群的不同服务器中，减少测试压力

- 分区： 把一张表的数据分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，提高IO读写性能
- 分库：分库是根据业务不同把相关的表切分到不同的数据库中，比如订单，登陆等。

